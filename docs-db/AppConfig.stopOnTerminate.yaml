id: AppConfig.stopOnTerminate
source_file: background-geolocation-types/src/core/config/AppConfig.ts
signature: 'stopOnTerminate?: boolean;'
description: |-
  Controls whether to continue location-tracking after the application is **terminated**.

  Defaults to **`true`**.
  When the user terminates the app, the plugin will call {@link BackgroundGeolocation.stop | stop()},
  ending tracking.
  Set {@link AppConfig.stopOnTerminate} to **`false`** to continue tracking after the app is terminated.

  If you *do* configure **`stopOnTerminate: false`**, your application **will** terminate immediately when the user swipes it away.
  However, Android and iOS behave very differently *after* termination:

  __iOS__

  Before an iOS app terminates, the SDK creates a **stationary geofence** of
  {@link GeoConfig.stationaryRadius} meters around the last known position.
  When the user moves beyond this stationary geofence (typically ~200 meters), iOS will
  **fully relaunch your application in the background**, and tracking will automatically resume.

  This works even after device reboot because geofences are monitored entirely by iOS at the OS level.

  In the illustration below, imagine the user terminated the application at the **red circle** on the right.
  As soon as the device moves **~200 meters**, exiting the stationary geofence, iOS re-launches the app
  and the SDK resumes tracking.

  ℹ️ *Demo video:*
  https://www.youtube.com/watch?v=aR6r8qV1TI8&t=214s

  ![](https://dl.dropboxusercontent.com/s/1uip231l3gds68z/screenshot-stopOnTerminate-ios.png?dl=0)

  __Android__

  Unlike iOS, Android does **not** pause tracking when the user terminates the app.
  The native background service continues running **headlessly**, even without the JS/UI process.

  If relying on headless mode, you must configure {@link HttpConfig.url} so that the background service
  can continue posting locations to your server.

  __See also__
  - {@link AppConfig.enableHeadless}
  - [Android Headless Mode](github:wiki/Android-Headless-Mode)
